/*
단순히 모든 부분합에 대해 검사하니까 시간초과가 났다.
마땅한 방법이 생각나지 않아 검색을 해보니 알고스팟의 부분합에 있는 문제와
똑같다는 언급이 있었다.

찾아보니 정말 똑같은 문제가 있었다.
부분합을 구할 때 mod 연산을 같이 해주고
나머지가 같은 것들은 카운트를 해서 그 중 2개를 고르는 조합연산을 통해
문제를 해결했다.

5 3
1 2 3 1 2

라고 인풋이 들어오면
2 3 1을 더해도 3으로 나눴을때 나머지가 0이되겠죠??

이것을 어떻게 찾냐???
하면

1 2 3 1 을 다더하면 7이 나오겟죠??
근데 인덱스 0까지의 합은 1입니다.

그렇다면
인덱스 1~3은 S3 - S0입니다.

S0의 나머지는 1
S3의 나머지 또한 1이죠

그렇다하면 나머지 두개가 같은 이 S3 와 S0을 뺀다면
나머지가 0이됩니다.
즉 이 둘을 뻇을 때 나머지가 0이라는 말입니다.

데이터를 받을 때마다 연속적으로 합을 구해서 mod값으로 나누고 나눈 나머지값들을 각각
카운트합니다.

그리고 m미만의 각 개수에 대해서 n(해당 모드의 개수)C2를 해주면됩니다.(n개 중에 2개를 고르는 방법)

주의할 점은 나머지가 0인경우 nC2 + 자기자신도 이미 나누어지기 때문에 자기자신의 개수까지 더해야한다는 점입니다.
*/

#include <iostream>
#include <vector>
using namespace std;

int n, m;
long long psum[1000001];

int main() {
	ios_base::sync_with_stdio(0);
	cin.tie(0);

	cin >> n >> m;
	long long ret = 0;
	vector<long long> count(m, 0);
	for (int i = 0; i < n; ++i) {
		long long num;
		cin >> num;
		if (i == 0)
			psum[i] = num % m;
		else
			psum[i] = (psum[i - 1] + num) % m;	//모듈러 연산 중요
		//나누어 지면 카운트
		if (psum[i] == 0)
			ret++;
		//해당 나머지의 개수를 기록
		count[psum[i]]++;
	}

	//두 번 이상 본 적 있다면 이 값중 두개를 선택하는 방법의 수를 더한다.
	// M C 2 
	// 예를들어 1~4 , 1~8 구간이 둘다 mod M 에서 나머지 2 이면 4~8 구간이 mod M 에서 0
	for (int i = 0; i < m; ++i)
		ret += (count[i] * (count[i] - 1)) / 2;

	cout << ret;

	return 0;
}